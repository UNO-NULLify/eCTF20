#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import json
import struct
import os
import wave
from argparse import ArgumentParser
#Replace
#from nacl import pwhash, secret, utils, encoding, public, hash
#from nacl.pwhash.argon2id import SALTBYTES, OPSLIMIT_SENSITIVE, MEMLIMIT_SENSITIVE
#import nacl.signing
#from nacl.public import PrivateKey, SealedBox
#end replace
import monocypher
import os
from makeAudio import make_sample
from subprocess import call
from pprint import pprint


def main():
    #Take in command line arguments.
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    #Take input from secret files
    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    users = json.load(open(os.path.abspath(args.user_secrets_path)))

    #Unique song ID for the song. In place of song name.
    #songID = utils.random(16).hex()  #size 32
    songID = os.urandom(16)  #size 32

    #Define hashing method
    #HASHER = hash.blake2b
    #HASHER = monocypher.blake2b()

    #Key used for securing encrypting and sharing the song. hash(hashpin + pin + SongName)
    #songKey = HASHER(bytes((users["users"][args.owner]["pin_hash"]+users["users"][args.owner]["pin"]+songID),
    #                        encoding="utf-8"), encoder=encoding.HexEncoder)

    songKey = monocypher.blake2b(bytes(users["users"][args.owner]["pin_hash"], encoding="utf-8") + \
                                bytes(users["users"][args.owner]["pin"], encoding="utf-8") + \
                                songID)

    #print("{}\n{}\n{}\n".format(users["users"][args.owner]["pin_hash"], users["users"][args.owner]["pin"], songID.hex()))

    song_str = (bytes(users["users"][args.owner]["pin_hash"], encoding="utf-8") + \
                bytes(users["users"][args.owner]["pin"], encoding="utf-8") + \
                songID).hex()

    songkey = monocypher.blake2b(song_str).hex()
    #regionKey = utils.random(32)
    regionKey = os.urandom(32)

    regionSecretList = []

    #for regionIn in args.region_list:
    #    pvt_key = public.PrivateKey(regions[regionIn]["priv_key"],encoder=encoding.HexEncoder)
    #    encrypted = SealedBox(pvt_key.public_key).encrypt(regionKey)
    #    print(f"region secret {encrypted.hex()}")
    #    regionSecretList.append([regionIn, encrypted.hex()])
    #    #print(f"decrypted:{SealedBox(pvt_key).decrypt(encrypted).hex()}") #This is how you decrypt the secret
   
    for r in args.region_list:
        pvt_key = regions[r]["priv_key"]
        pub_key = regions[r]["pub_key"]
        encrypted = monocypher.lock(bytes(pub_key, encoding="utf-8"), os.urandom(24), regionKey)
        regionSecretList.append(encrypted[1].hex())

    print("Region Secrets:\n")
    pprint(regionSecretList)

    #hardwareSecretHash = HASHER(bytes((users["users"][args.owner]["hw_secret"]+songID),
    #                        encoding="utf-8"), encoder=encoding.HexEncoder)
    #hardwareSecretHash30 = HASHER(bytes((users["users"][args.owner]["hw_secret"]+songID+"30"),
    #                        encoding="utf-8"), encoder=encoding.HexEncoder)
    hardwareSecretHash = monocypher.blake2b(bytes(users["users"][args.owner]["hw_secret"],
                         encoding="utf-8") + songID).hex()
    hardwareSecretHash30 = monocypher.blake2b(bytes(users["users"][args.owner]["hw_secret"],
                           encoding="utf-8") + songID+bytes("30",
                           encoding="utf-8")).hex()

    #print("{}\n{}\n{}\n{}\n".format(songkey, regionKey, hardwareSecretHash, hardwareSecretHash30))

    print(f"encryption parts:\nSong Key: {songKey.hex()}\nRegion Key: {regionKey.hex()}\nHW Secret Hash: {hardwareSecretHash}\nHW 30: {hardwareSecretHash30}")
    print(f"Creating 30 second chunk:")
    smallFile = make_sample(args.infile)
    parent = os.path.abspath(os.path.join(args.outfile, os.pardir))
    out_f_name = args.outfile.split("/")[-1]
    name = out_f_name.split(".")[0] + "_sample." + out_f_name.split(".")[1]
    ### TODO: Check the 30path and owner path
    #call(["./encryptFile", "--owner", "DrewGriess",
    #"--SongName", "namee",
    #"--30path", smallFile,
    #"--30secret", str(hardwareSecretHash30.hex()),
    #"--fullpath", args.infile,
    #"--secret", str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex()),
    #"--regionSecrets", "tempregionsec",
    #"--regions", "USA",
    #"--songID", songID])
    #smallFile, os.path.join(parent, name), str(hardwareSecretHash30.hex())])
    #call(["./encryptFile", args.infile, args.outfile, str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex())])
    #print(f"Decrypting File...")
    #call(["./decryptFile", args.outfile, "PlayMe", str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex())])

if __name__ == '__main__':
    main()
