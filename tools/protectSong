#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import json
import struct
import os
import wave
from argparse import ArgumentParser
import monocypher
import os
from makeAudio import make_sample
from subprocess import call
from pprint import pprint


def main():
    #Take in command line arguments.
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    #Take input from secret files
    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    users = json.load(open(os.path.abspath(args.user_secrets_path)))

    #Unique song ID for the song. In place of song name.

    songName = bytes(args.infile.split("/")[-1], encoding="utf-8")  #size 32

    print(f"The pin is {users['users'][args.owner]['pin']}")
    print(f"The owner of the song is {args.owner}")
    print(f"The ownerID of the song is {users['users'][args.owner]['id']}")

    songKey = monocypher.blake2b(bytes(users["users"][args.owner]["pin_hash"], encoding="utf-8") + \
                                bytes(users["users"][args.owner]["pin"], encoding="utf-8") + \
                                songName)

    regionKey = os.urandom(32)

    regionSecretList = []

    for r in args.region_list:
        rand_pass = regions[r]["rand_pass"]
        nonce = bytes(24)
        encrypted = monocypher.lock(bytes.fromhex(rand_pass), nonce, regionKey)

        print(f"RANDOM PASS: {rand_pass}")
        print(f"RANDOM PASS BYTES: {bytes.fromhex(rand_pass)}")
        print(f"ENCRYPTED: {encrypted[1].hex() + encrypted[0].hex()}")
        print(f"Region KEY: {regionKey.hex()}")
        #print(f"DECRYPTED: {monocypher.lock(bytes(rand_pass, encoding="utf-8"), b'', regionKey)}")

        regionSecretList.append(encrypted[1].hex() + encrypted[0].hex())

    print("Region Secrets:\n")
    pprint(regionSecretList)

    hardwareSecretHash = monocypher.blake2b(bytes(users["users"][args.owner]["hw_secret"],
                         encoding="utf-8") + songName).hex()
    hardwareSecretHash30 = monocypher.blake2b(bytes(users["users"][args.owner]["hw_secret"],
                           encoding="utf-8") + songName+bytes("30",
                           encoding="utf-8")).hex()


    print(f"encryption parts:\nSong Key: {songKey.hex()}\nRegion Key: {regionKey.hex()}\nHW Secret Hash: {hardwareSecretHash}\nHW 30: {hardwareSecretHash30}")
    print(f"Creating 30 second chunk:")
    smallFile = make_sample(args.infile)
    parent = os.path.abspath(os.path.join(args.outfile, os.pardir))
    out_f_name = args.outfile.split("/")[-1]
    name = out_f_name.split(".")[0] + "_sample." + out_f_name.split(".")[1]

    region_ids_tmp = []
    for r in args.region_list:
        region_ids_tmp.append(regions[r]["id"])

    call(["./encryptSong",
        str(users["users"][args.owner]["id"]),
        ",".join([str(x) for x in region_ids_tmp]),
        ",".join([str(x) for x in regionSecretList]),
        args.infile.split("/")[-1],
        smallFile,
        str(hardwareSecretHash30),
        args.infile,
        str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash),
        args.outfile,
        str(users["root_sign"]),
        str(users["root_verify"])
    ])

if __name__ == '__main__':
    main()
