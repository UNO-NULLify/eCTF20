#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import json
import struct
import os
import wave
from argparse import ArgumentParser
import numpy as np
from nacl import pwhash, secret, utils, encoding, public, hash
from nacl.pwhash.argon2id import SALTBYTES, OPSLIMIT_SENSITIVE, MEMLIMIT_SENSITIVE
import nacl.signing
from nacl.public import PrivateKey, SealedBox
from makeAudio import make_sample
from subprocess import call


def main():
    #Take in command line arguments.
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    #Take input from secret files
    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    users = json.load(open(os.path.abspath(args.user_secrets_path)))

    #Unique song ID for the song. In place of song name.
    songID = utils.random(16).hex()

    #Define hashing method
    HASHER = hash.blake2b

    #Key used for securing encrypting and sharing the song. hash(hashpin + pin + SongName)
    songKey = HASHER(bytes((users["users"][args.owner]["pin_hash"]+users["users"][args.owner]["pin"]+songID),
                            encoding="utf-8"), encoder=encoding.HexEncoder)
    regionKey = utils.random(32)

    regionSecretList = []

    for regionIn in args.region_list:
        pvt_key = public.PrivateKey(regions[regionIn]["priv_key"],encoder=encoding.HexEncoder)
        encrypted = SealedBox(pvt_key.public_key).encrypt(regionKey)
        regionSecretList.append([regionIn, encrypted.hex()])
        #print(f"decrypted:{SealedBox(pvt_key).decrypt(encrypted).hex()}") #This is how you decrypt the secret

    hardwareSecretHash = HASHER(bytes((users["users"][args.owner]["hw_secret"]+songID),
                            encoding="utf-8"), encoder=encoding.HexEncoder)
    hardwareSecretHash30 = HASHER(bytes((users["users"][args.owner]["hw_secret"]+songID+"30"),
                            encoding="utf-8"), encoder=encoding.HexEncoder)
    #print(f"encryption parts: {str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex())}")
    print(f"Creating 30 second chunk:")
    smallFile = make_sample(args.infile)
    parent = os.path.abspath(os.path.join(args.outfile, os.pardir))
    out_f_name = args.outfile.split("/")[-1]
    name = out_f_name.split(".")[0] + "_sample." + out_f_name.split(".")[1]
    call(["./encryptFile", smallFile, os.path.join(parent, name), str(hardwareSecretHash30.hex())])
    call(["./encryptFile", args.infile, args.outfile, str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex())])
    #call(["./decryptFile", "out", "PlayMe", str(songKey.hex())+str(regionKey.hex())+str(hardwareSecretHash.hex())])

if __name__ == '__main__':
    main()
