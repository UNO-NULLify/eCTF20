#!/usr/bin/env python3
"""
Description: Creates user specific secrets
Use: Once per user
"""

import json
from argparse import ArgumentParser
# Replace
#from nacl import pwhash, secret, utils, encoding, public, hash
#from nacl.pwhash.argon2id import SALTBYTES, OPSLIMIT_SENSITIVE, MEMLIMIT_SENSITIVE
#import nacl.signing
# End Replace
import monocypher
import os


#Define hashing method
#HASHER = hash.blake2b

ARGON_BLOCKS = 8
ARGON_ITTERS = 3

def main(user_list, outfile):
    """writes user secrets to json file
    args:
        users_ (string): string of users and pins seperated by colons e.g. user1:123456789
        outfile (string): name of file to write user_secrets to """
    #print("Salt Bytes: {}\nOps Limit: {}\nMem Limit: {}".format(SALTBYTES, OPSLIMIT_SENSITIVE, MEMLIMIT_SENSITIVE))
    try:
        secrets = open(outfile, "w")
    except Exception as e:
        print("Unable to open secrets file: %s" % (e,))
        return 1
    try:
        i = 1
        user_dict = {}
        for user in user_list:
            u = user.split(":")
            #salt = utils.random(SALTBYTES) # 16 bytes
            salt = os.urandom(16)
            # generating an argon2id hash of user pin with custom salt; encoded in base64
            # OPSLIMIT_SENSITIVE MEMLIMIT_SENSITIVE are default settings for kdf function below
            #hashed = pwhash.argon2id.str(bytes(u[1], encoding="utf-8"))
            hashed = monocypher.argon2i_32(ARGON_BLOCKS,
                                           ARGON_ITTERS,
                                           bytes(u[1], encoding="utf-8"),
                                           salt)

            print(hashed.hex())

            # generate a public / private keypair (Curve25519)
            #pvt_key = public.PrivateKey.generate()
            pair = monocypher.generate_key_exchange_key_pair()
            pvt_key = pair[0]
            public_key = pair[1]

            #Key used for securing the private key. hash(hashpin + pin + salt)
            #secure_key = HASHER(bytes((hashed.decode()+u[1]+salt.hex()), encoding="utf-8"),
            #                            encoder=encoding.HexEncoder)[:32]
            secure_key = monocypher.blake2b(hashed + bytes(u[1], encoding="utf-8"), salt)

            #Encrypting private key with the secure key

            #print(f"Encrypting user private key with {secure_key} length {len(secure_key)}")
            #box = secret.SecretBox(secure_key)
            #pvt_key_enc = box.encrypt(bytes(pvt_key))
            pvt_key_enc = monocypher.lock(secure_key, i.to_bytes(24, 'big'), pvt_key)


            user_dict[u[0]] = {"id": i,
                               "pin": u[1],                # PIN   NEVER TOUCH DEVICE
                               "pin_hash": hashed.hex(),                                  # PIN hash convert bytes(hash, encoding="utf-8")
                               "salt": salt.hex(),                                        # to convert .hex() back to bytes bytes.fromhex(salt-as-hex)
                               "pvt_key": pvt_key.hex(),                  #NEVER TOUCH DEVICE
                               "pvt_key_enc": pvt_key_enc[1].hex() + pvt_key_enc[0].hex(),                          #  nacl.bindings.crypto_aead_chacha20poly1305...?
                               "pub_key": public_key.hex(),
                               "hw_secret": monocypher.generate_key(length=10).hex(),
                               }
            i = i+1
        # generate pubic private key pair for additional integrity checks (Curve25519)
        pair = monocypher.generate_signing_key_pair()
        #signing_key = nacl.signing.SigningKey.generate()
        signing_key = pair[0]

        #EXAMPLE USE CASE: DELETE IN FINAL CODE
        #print(signing_key.encode(encoder=encoding.HexEncoder))
        #print(signing_key.encode(encoder=encoding.HexEncoder).hex())
        #key_hex = signing_key.encode(encoder=encoding.HexEncoder).hex()
        #test_key = nacl.signing.SigningKey(bytes.fromhex(key_hex), encoder=encoding.HexEncoder)
        #signed_msg = test_key.sign(b"Attack at Dawn")
        #bad_msg = signed_msg[:-4]

        #verify_key = signing_key.verify_key
        verify_key = pair[1]
        #print(verify_key.verify(signed_msg))

        json_dict = {}
        json_dict["root_sign"] = signing_key.hex()        #.encode(encoder=encoding.HexEncoder).hex()
        json_dict["root_verify"] = verify_key.hex()       #.encode(encoder=nacl.encoding.HexEncoder).hex()
        json_dict["users"] = user_dict

    except IndexError:
        raise Exception(
            "Unable to parse user name and pin. Please make sure you entered the user-list as "
            "space seperated pairs of usernames and pins. Example: --user-list user1:12345678 user2:12345689")
    info = json.dumps(json_dict, indent=4, sort_keys=True)
    secrets.write(info)
    secrets.close()


def get_args():
    """gets arguments from command line"""
    parser = ArgumentParser(description='main interface to provision system')
    parser.add_argument('--user-list', nargs='+',
                        help='list of users and pins seperated by a colon: "user1:12345678 user2:12345679" ',
                        required=True)
    parser.add_argument('--outfile', help='location to save user secrets file', required=True)
    args = parser.parse_args()
    return args.user_list, args.outfile


if __name__ == '__main__':
    users, loc = get_args()
    #print("generating user specific secrets")
    main(users, loc)
