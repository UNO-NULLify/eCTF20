(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{211:function(t,n,e){"use strict";e.r(n);var a=e(0),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"authentication"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#authentication"}},[t._v("#")]),t._v(" Authentication")]),t._v(" "),e("p",[t._v("Explination of how we use monocypher to do logins and blah blah blah")]),t._v(" "),e("h2",{attrs:{id:"login"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#login"}},[t._v("#")]),t._v(" Login")]),t._v(" "),e("p",[t._v("The "),e("code",[t._v("login")]),t._v(" function authenticates the user by takin in a username and pin. The function checks if the username matches any existing user stored on the player, generates a hash from the input pin, and compares it to the hash stored under the aforementioned user's secret struct within the player. The pin is hashed with "),e("code",[t._v("argon2id")]),t._v(", using 16-byte random salts, and is iterated 3 times.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('void login() {\n    if (s.logged_in) {\n        mb_printf("Already logged in. Please log out first.\\r\\n");\n        memcpy((void*)c->username, s.username, USERNAME_SZ);\n        memcpy((void*)c->pin, s.pin, MAX_PIN_SZ);\n    } else {\n        for (int i = 0; i < PROVISIONED_USERS; i++) {\n            // search for matching username\n            if (!strcmp((void*)c->username, user_data[i].name)) {\n                // check if pin matches\n            \t//secrets pin hash to bytes\n            \tuint8_t usr_pin_bytes[ARGON_HASH_SZ] = {0};\n            \tbyte_me(usr_pin_bytes, user_data[i].pin_hash, strlen(user_data[i].pin_hash));\n            \t//\n            \t//make comparison hash\n            \tuint8_t cmp_hash[ARGON_HASH_SZ] = {0};\n            \t//work area\n            \tuint8_t *work_area;\n            \twork_area = (uint8_t *) malloc(ARGON_BLOCKS*1024);\n            \tcrypto_wipe(work_area, sizeof(work_area);\n            \tif (work_area == NULL)\n            \t{\n            \t\tmb_printf("\\r\\nFailed to allocate the work area. Aborting.\\r\\n");\n            \t\tcrypto_wipe((void*)c->username, USERNAME_SZ);\n                    crypto_wipe((void*)c->pin, MAX_PIN_SZ);\n            \t\treturn;\n            \t}\n            \t//salt bytes\n            \tuint8_t salt_bytes[ARGON_SALT_SZ] = {0};\n            \tbyte_me(salt_bytes, user_data[i].salt, strlen(user_data[i].salt));\n                crypto_argon2i(cmp_hash,\n            \t\t\t\t   ARGON_HASH_SZ,\n\t\t\t\t\t\t\t   work_area,\n\t\t\t\t\t\t\t   ARGON_BLOCKS,\n\t\t\t\t\t\t\t   ARGON_ITTERS,\n\t\t\t\t\t\t\t   (void*)c->pin,\n\t\t\t\t\t\t\t   strlen((void*)c->pin),\n\t\t\t\t\t\t\t   salt_bytes,\n\t\t\t\t\t\t\t   ARGON_SALT_SZ);\n                if (!crypto_verify32(cmp_hash, usr_pin_bytes)) {\n                    //update states\n                    s.logged_in = 1;\n                    c->login_status = 1;\n                    memcpy(s.username, (void*)c->username, USERNAME_SZ);\n                    memcpy(s.pin, (void*)c->pin, MAX_PIN_SZ);\n                    s.uid = user_data[i].id;\n                    mb_printf("Logged in for user \'%s\'\\r\\n", c->username);\n                    free(work_area);\n                    return;\n                } else {\n                    // reject login attempt\n                    mb_printf("Incorrect pin for user \'%s\'\\r\\n", c->username);\n                    crypto_wipe((void*)c->username, USERNAME_SZ);\n                    crypto_wipe((void*)c->pin, MAX_PIN_SZ);\n                    free(work_area);\n                    return;\n                }\n            }\n        }\n\n        // reject login attempt\n        mb_printf("User not found\\r\\n");\n        crypto_wipe((void*)c->username, USERNAME_SZ);\n        crypto_wipe((void*)c->pin, MAX_PIN_SZ);\n    }\n}\n')])])]),e("h2",{attrs:{id:"logout"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#logout"}},[t._v("#")]),t._v(" Logout")]),t._v(" "),e("p",[t._v("The "),e("code",[t._v("logout")]),t._v(" function terminates a user's session on the miPod if and only if they are first logged in. This function zeros out the command channel "),e("code",[t._v("c")]),t._v(" of all references to the user, changes the miPod's internal state "),e("code",[t._v("s.logged_in")]),t._v(" to 0, has no parameters, and returns "),e("code",[t._v("void")]),t._v(".")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('void logout() {\n    if (c->login_status) {\n        mb_printf("Logging out...\\r\\n");\n        s.logged_in = 0;\n        c->login_status = 0;\n        memset((void*)c->username, 0, USERNAME_SZ);\n        memset((void*)c->pin, 0, MAX_PIN_SZ);\n        s.uid = 0;\n    } else {\n        mb_printf("Not logged in\\r\\n");\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);