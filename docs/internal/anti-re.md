# Anti-Reverse Engineering

## Disabling Core Dumps
Core dumps are a disk file containing an image of the process's memory at the time of termination. This image can be used in a debugger to inspect the state of the program at the time that it terminated. Core dumps can be simply generated by sending the correct signal to the program. There is also `gcore` which is a program that will allow a user to get a core dump of a program and keep the original program running.

### madvise
//TODO

### prctl
prctl() gives a program control of it's own process operations. When used in conjunction with the `PR_SET_DUMPABLE` option it can be used to disable core dumping entirely in the current process.
```man
PR_SET_DUMPABLE (since Linux 2.3.20)
              Set the state of the "dumpable" flag, which determines whether
              core dumps are produced for the calling process upon delivery
              of a signal whose default behavior is to produce a core dump.

              In kernels up to and including 2.6.12, arg2 must be either 0
              (SUID_DUMP_DISABLE, process is not dumpable) or 1
              (SUID_DUMP_USER, process is dumpable).
              
              Processes that are not dumpable can not be attached via
              ptrace(2) PTRACE_ATTACH; see ptrace(2) for further details.

              If a process is not dumpable, the ownership of files in the
              process's /proc/[pid] directory is affected as described in
              proc(5).
```

We effectively implemented it with the following line:
```C
prctl(PR_SET_DUMPABLE, SUID_DUMP_DISABLE);
```

## Preventing Debugging
The ptrace() system call provides a means by which one process (the “tracer”) may observe and control the execution of another process (the “tracee”), and examine and change the tracee’s memory and registers. It is primarily used to implement breakpoint debugging and system call tracing.

### Using PTRACE_ATTACH
```C
int main(int p_argc, char* p_argv[])
{
  (void)p_argc;
  (void)p_argv;
  int fork_pid = fork();
  if (fork_pid == 0)
  {
    // trace the parent process
    if (ptrace(PTRACE_ATTACH, getppid(), NULL, NULL) != 0)
    {
      exit(EXIT_FAILURE);
    }
    ptrace(PTRACE_SETOPTIONS, getppid(), NULL, PTRACE_O_TRACEFORK | PTRACE_O_EXITKILL);
    // restart the parent so it can keep processing like normal
    int status = 0;
    wait(&status);
    ptrace(PTRACE_CONT, getppid(), NULL, NULL);
    // handle any signals that may come in from tracees
    while (true)
    {
      int pid = wait(&status);
      if (status >> 16 == PTRACE_EVENT_FORK)
      {
        // follow the fork
        long newpid = 0;
        ptrace(PTRACE_GETEVENTMSG, pid, NULL, &newpid);
        ptrace(PTRACE_ATTACH, newpid, NULL, NULL);
        ptrace(PTRACE_CONT, newpid, NULL, NULL);
      }
    ptrace(PTRACE_CONT, pid, NULL, NULL);
  }
}
```
The code above will fork() a child process that becomes the tracer of the parent program process via `PTRACE_ATTACH`. It will also automatically begin tracing any forks that program creates due to the `PTRACE_SETOPTIONS` call. No one can simply attach to the main Trouble process since it is being traced by a child. The `PTRACE_O_TRACEFORK` option will automatically trace any forks that the program creates and `PTRACE_O_EXITKILL` will send `SIGKILL` signals to all tracees if the tracer is killed.

### Preventing Tracers from being Traced
```C
void checkProc()
{
  FILE* proc_status = fopen("/proc/self/status", "r");
  if (proc_status == NULL)
  {
    return;
  }
  char line[1024] = { };
  char *fgets(char *s, int size, FILE *stream);
  while (fgets(line, sizeof(line), proc_status) != NULL)
  {
    const char traceString[] = "TracerPid:";
    char* tracer = strstr(line, traceString);
    if (tracer != NULL)
    {
      int pid = atoi(tracer + sizeof(traceString) - 1);
      if (pid != 0)
      {
        fclose(proc_status);
        kill(getppid(), SIGKILL);
        exit(EXIT_FAILURE);
      }
    }
  }
  fclose(proc_status);
}
```
The issue with creating a forked process to trace the main program is that the new child process itself can be traced. The code above checks the "TracerPid" entry in the `/proc/self/status` file. If the value is not zero then a debugger has attached. If a debugger is attached then signal to the parent pid and exit. This function can be implemented in a loop with a non-blocking `waitpid` call to kill any debugger that get's attached to the child tracer. It does not outright deny a debugger from being attached, but it doesn't allow one to be attached for very long either.

### Detecting before main()
```C
void __attribute__((constructor)) before_main()
{
  checkProc();
}
```
Debuggers can still sometimes run the program until the tracing child detects the debugger and kills the program. Luckily, you can add code that will execute before main() is executed. Functions with the `constructor` attribute will be called before main(), therefore causing debuggers to exit immediately.

## Preventing Patching
### Computing Checksums
//TODO
### Function Encryption
//TODO
